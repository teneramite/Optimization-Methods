# Задание 1: Решение задач линейного программирования (Симплекс-метод)

## Автор
**ФИО:** Кисель Софья Михайловна 
**Поток:** 1.1

## Описание задачи

Реализована программа для решения задач линейного программирования (ЗЛП) симплекс-методом. Программа выполняет полный цикл решения:

1. Считывание постановки ЗЛП из файла
2. Приведение задачи к каноническому виду
3. Формирование вспомогательной задачи
4. Решение вспомогательной задачи
5. Переход к основной задаче
6. Решение основной задачи
7. Вывод результата: оптимальная точка и значение целевой функции

### Вариант 17

**Задача:**
```
Максимизировать: Z = x₁ + 3x₂ + 2x₃ + x₄

При ограничениях:
  x₁ + x₂ + 2x₄ ≤ 8
  x₂ + x₃ + x₄ = 6
  2x₁ + x₃ ≥ 2
  x₁, x₂, x₃, x₄ ≥ 0
```

## Алгоритм решения

### Псевдокод симплекс-метода

```
АЛГОРИТМ SimplexMethod(c, A, b, constraint_types, maximize)
ВХОД: 
  c - вектор коэффициентов целевой функции
  A - матрица коэффициентов ограничений
  b - вектор правых частей
  constraint_types - типы ограничений
  maximize - флаг максимизации/минимизации

ВЫХОД:
  solution - оптимальное решение
  optimal_value - оптимальное значение
  status - статус решения

НАЧАЛО
  1. ПриведениеККаноническомуВиду(A, b, c, constraint_types)
     // Добавление дополнительных и искусственных переменных
     ДЛЯ каждого ограничения i:
       ЕСЛИ constraint_type[i] == '<=' ТОГДА
         Добавить дополнительную переменную (slack)
       ИНАЧЕ ЕСЛИ constraint_type[i] == '>=' ТОГДА
         Добавить дополнительную переменную со знаком минус
         Добавить искусственную переменную
       ИНАЧЕ  // '='
         Добавить искусственную переменную
     КОНЕЦ ДЛЯ
  
  2. Фаза1_ПоискДопустимогоБазиса()
     ЕСЛИ есть искусственные переменные ТОГДА
       Создать вспомогательную целевую функцию:
         c_aux = минимизировать сумму искусственных переменных
       
       basis = искусственные переменные + дополнительные
       
       optimal_aux = РешитьСимплексом(c_aux, A, b, basis)
       
       ЕСЛИ optimal_aux > ε ТОГДА
         ВОЗВРАТ (NULL, NULL, 'infeasible')
       КОНЕЦ ЕСЛИ
       
       Удалить искусственные переменные из базиса
     КОНЕЦ ЕСЛИ
  
  3. Фаза2_РешениеОсновнойЗадачи()
     Удалить искусственные переменные из матрицы
     
     optimal = РешитьСимплексом(c, A, b, basis)
     
     ЕСЛИ optimal == NULL ТОГДА
       ВОЗВРАТ (NULL, NULL, 'unbounded')
     КОНЕЦ ЕСЛИ
     
     solution = ИзвлечьРешениеИзБазиса(basis, A, b)
     ВОЗВРАТ (solution, optimal, 'optimal')

ФУНКЦИЯ РешитьСимплексом(c, A, b, basis)
  iteration = 0
  
  ПОКА iteration < MAX_ITERATIONS:
    iteration = iteration + 1
    
    // Создание симплекс-таблицы
    tableau = СоздатьСимплексТаблицу(A, b, c, basis)
    
    // Вычисление приведенных стоимостей
    B = A[:, basis]
    c_B = c[basis]
    B_inv = Обратная(B)
    reduced_costs = c - c_B · B_inv · A
    
    // Проверка критерия оптимальности
    ЕСЛИ все reduced_costs[j] ≤ 0 (для минимизации) ТОГДА
      solution = ИзвлечьРешение(basis, B_inv, b)
      ВОЗВРАТ оптимальное значение
    КОНЕЦ ЕСЛИ
    
    // Выбор входящей переменной (правило Данцига)
    entering = argmax(reduced_costs)
    
    // Выбор выходящей переменной (min ratio test)
    column = B_inv · A[:, entering]
    ratios = b / column  // только для положительных элементов
    
    ЕСЛИ все ratios == ∞ ТОГДА
      ВОЗВРАТ NULL  // задача неограничена
    КОНЕЦ ЕСЛИ
    
    leaving_idx = argmin(ratios)
    leaving = basis[leaving_idx]
    
    // Обновление базиса
    basis[leaving_idx] = entering
    
    // Пересчет матрицы (pivoting)
    B = A[:, basis]
    B_inv = Обратная(B)
    A = B_inv · A
    b = B_inv · b
  КОНЕЦ ПОКА
  
  ВОЗВРАТ NULL  // превышено максимальное количество итераций
КОНЕЦ ФУНКЦИИ

КОНЕЦ АЛГОРИТМА
```

### Краткое описание этапов

1. **Приведение к каноническому виду:**
   - Преобразование неравенств в равенства через добавление дополнительных переменных
   - Добавление искусственных переменных для ограничений типа "≥" и "="

2. **Фаза 1 (поиск допустимого базисного решения):**
   - Минимизация суммы искусственных переменных
   - Если минимум > 0, то задача не имеет допустимых решений
   - Иначе получаем допустимый базис для основной задачи

3. **Фаза 2 (решение основной задачи):**
   - Итеративное улучшение решения через выбор входящей и выходящей переменных
   - Критерий оптимальности: все приведенные стоимости неположительны
   - Критерий неограниченности: нет положительных элементов в столбце входящей переменной

## Инструкция по запуску

### Требования

- Python 3.7+
- NumPy

### Установка зависимостей

```bash
pip install numpy
```

### Запуск программы

**Вариант 1: Запуск демонстрации (рекомендуется)**

```bash
cd task1_linear_programming
python demo.py
```

**Вариант 2: Решение своей задачи из файла**

```bash
python -c "from simplex_solver import solve_from_file; solve_from_file('input_variant17.json')"
```

**Вариант 3: Использование как модуль**

```python
from simplex_solver import SimplexSolver

solver = SimplexSolver(
    c=[1, 3, 2, 1],  # коэффициенты целевой функции
    A=[[1, 1, 0, 2], [0, 1, 1, 1], [2, 0, 1, 0]],  # матрица ограничений
    b=[8, 6, 2],  # правые части
    constraint_types=['<=', '=', '>='],  # типы ограничений
    maximize=True  # максимизация
)

solution, optimal_value, status = solver.solve()
print(f"Решение: {solution}")
print(f"Оптимальное значение: {optimal_value}")
```

### Формат входного файла (JSON)

```json
{
  "description": "Вариант 17",
  "maximize": true,
  "objective": [1, 3, 2, 1],
  "constraints_matrix": [
    [1, 1, 0, 2],
    [0, 1, 1, 1],
    [2, 0, 1, 0]
  ],
  "constraints_rhs": [8, 6, 2],
  "constraint_types": ["<=", "=", ">="],
  "variables": ["x1", "x2", "x3", "x4"]
}
```

## Демонстрация работы

### Пример выполнения на варианте 17

```
================================================================================
РЕШЕНИЕ ЗАДАЧИ ЛИНЕЙНОГО ПРОГРАММИРОВАНИЯ
================================================================================

Шаг 1: Приведение к каноническому виду
Исходные переменные: 4
Дополнительные переменные: 2
Искусственные переменные: 2
Всего переменных: 8
Ограничений: 3

Шаг 2: Решение двухфазным симплекс-методом

--- ФАЗА 1: Поиск допустимого базисного решения ---

--- ФАЗА 2: Решение основной задачи ---

Итерация 1:
Базис: ['x4', 'x5', 'x6', 'x7']
Текущее значение целевой функции: 0.000000
Входящая переменная: x1
Выходящая переменная: x5

Итерация 2:
Базис: ['x4', 'x1', 'x6', 'x7']
Текущее значение целевой функции: 100.000000
...

================================================================================
РЕЗУЛЬТАТ: OPTIMAL
Оптимальное значение целевой функции: 20.000000
Оптимальная точка (первые 4 переменных):
  x1 = 0.000000
  x2 = 4.000000
  x3 = 2.000000
  x4 = 0.000000
================================================================================
```

### Сравнение с Excel Solver

Для проверки корректности результата:

1. Откройте Excel
2. Введите данные задачи в таблицу
3. Перейдите в Данные → Анализ "Что если" → Поиск решения
4. Настройте параметры:
   - Целевая ячейка: формула целевой функции
   - Изменяя ячейки: переменные решения
   - Ограничения: введите все ограничения задачи
5. Нажмите "Найти решение"

Результаты должны совпадать с точностью до округления.

## Структура кода

```
task1_linear_programming/
├── simplex_solver.py      # Основной модуль с реализацией симплекс-метода
├── input_variant17.json   # Входные данные для варианта 17
├── demo.py                # Демонстрация работы на различных примерах
└── README.md              # Данный файл
```

### Основные классы и функции

**Класс SimplexSolver:**
- `__init__()` - инициализация решателя
- `solve()` - полное решение ЗЛП
- `_to_canonical_form()` - приведение к каноническому виду
- `_phase1()` - фаза 1 двухфазного симплекс-метода
- `_phase2()` - фаза 2 двухфазного симплекс-метода
- `_simplex_method()` - основной симплекс-метод
- `_create_tableau()` - создание симплекс-таблицы
- `_pivot()` - выполнение поворотного преобразования
- `_extract_solution()` - извлечение решения из базиса

**Вспомогательные функции:**
- `load_problem_from_json()` - загрузка задачи из JSON файла
- `solve_from_file()` - решение задачи из файла

## Рефлективный вывод

### Что было полезного

1. **Глубокое понимание симплекс-метода:** Реализация алгоритма с нуля позволила понять все нюансы работы метода, включая двухфазный симплекс, добавление искусственных переменных и критерии оптимальности.

2. **Работа с матричными операциями:** Получен практический опыт работы с NumPy, обращением матриц, решением систем линейных уравнений.

3. **Понимание вычислительных проблем:** Столкнулся с проблемами численной устойчивости при обращении вырожденных матриц, научился использовать псевдообратные матрицы.

4. **Структурирование кода:** Разбиение сложного алгоритма на логические модули помогло сделать код читаемым и поддерживаемым.

### Трудности и их преодоление

1. **Выбор начального базиса:** Изначально было непонятно, как правильно формировать начальный базис при наличии ограничений разных типов. Решение пришло через изучение двухфазного симплекс-метода и использование искусственных переменных.

2. **Численная нестабильность:** При работе с плохо обусловленными матрицами возникали проблемы с обращением. Решение - использование `np.linalg.pinv()` вместо `np.linalg.inv()` в критических местах.

3. **Отладка критериев:** Изначально критерий оптимальности был реализован неверно (путаница с максимизацией и минимизацией). Помогло внимательное изучение теории и тестирование на простых примерах с известными решениями.

4. **Обработка граничных случаев:** Необходимо было учесть случаи неограниченной задачи, отсутствия допустимых решений, вырожденности. Для каждого случая добавлены соответствующие проверки.

### Выводы

Выполнение данной работы дало твердое понимание одного из фундаментальных алгоритмов оптимизации. Симплекс-метод, несмотря на свою теоретическую сложность, имеет элегантную реализацию и широкое применение в практических задачах. Полученные навыки работы с линейным программированием будут полезны при решении задач оптимизации ресурсов, планирования производства и логистики.
